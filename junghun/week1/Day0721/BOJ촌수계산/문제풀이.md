# 촌수 계산 - DFS와 인접 리스트 활용

## 개요

이 프로젝트는 주어진 그래프를 인접 리스트로 표현하고, 깊이 우선 탐색(DFS)를 사용하여 두 노드 간의 촌수를 계산하는 문제를 해결합니다. 노드 번호가 1부터 시작하는 점을 고려하여 구현되었습니다. 촌수가 없는 경우에는 -1을 출력하도록 설정되어 있습니다.

## 문제 접근 방법

1. **인접 리스트로 그래프 표현**:
    - 주어진 입력 값을 인접 리스트로 변환합니다. 각 노드는 연결된 다른 노드들을 리스트로 가집니다.
    - 노드 번호가 1부터 시작하므로 배열과 리스트의 인덱스를 1씩 더하여 관리합니다.

2. **깊이 우선 탐색(DFS)**:
    - DFS 알고리즘을 사용하여 시작점에서 도착점까지의 깊이를 계산합니다.
    - 방문한 노드를 추적하여 무한 루프에 빠지지 않도록 합니다.
    - DFS를 통해 목적지에 도달하면 현재 깊이를 결과로 저장합니다.

3. **초기화**:
    - 촌수가 없는 경우 -1을 출력해야 하는 조건이 있으므로, 초기 `result` 값을 -1로 설정합니다.

## 주요 기능

- **그래프 입력 처리**:
    - 입력된 노드 간의 연결 정보를 인접 리스트 형태로 저장합니다.

- **DFS 탐색 함수**:
    - 재귀적으로 DFS를 수행하여 두 노드 간의 촌수를 계산합니다.

- **결과 출력**:
    - 탐색 결과를 기반으로 두 노드 간의 촌수를 출력합니다. 촌수가 없을 경우 -1을 출력합니다.

## 코드 구조

1. **그래프 초기화**:
    - 입력된 노드 수와 간선 정보를 기반으로 인접 리스트를 생성합니다.

2. **DFS 함수**:
    - 시작 노드에서 출발하여 목표 노드에 도달할 때까지 탐색을 수행합니다.
    - 방문한 노드를 체크하고, 도착 시 결과를 갱신합니다.

3. **메인 함수**:
    - 입력을 받아 그래프를 초기화하고, DFS 탐색을 시작합니다.
    - 최종 결과를 출력합니다.

## 예제

다음은 코드 사용 예제입니다.

### 입력

```
노드 수: 7
간선 수: 6
연결 정보: 
1 2
1 3
2 4
2 5
3 6
3 7
시작점: 1
도착점: 5
```

### 출력

```
3
```

## 코드 구현

```java
public class Main {
    static int result = -1;
    static ArrayList<Integer>[] relation;
    static boolean[] visited;

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        relation = new ArrayList[N + 1];
        visited = new boolean[N + 1];

        for (int i = 1; i <= N; i++) {
            relation[i] = new ArrayList<>();
        }

        StringTokenizer st = new StringTokenizer(br.readLine());
        int x = Integer.parseInt(st.nextToken());
        int y = Integer.parseInt(st.nextToken());

        int m = Integer.parseInt(br.readLine());
        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int parent = Integer.parseInt(st.nextToken());
            int child = Integer.parseInt(st.nextToken());

            relation[parent].add(child);
            relation[child].add(parent);
        }

        dfs(x,y,0);
        System.out.println(result);
    }

    private static void dfs(int start,int end, int depth) {
        if (start == end) {
            result = depth;
            return;
        }

        visited[start] = true;
        for (int i = 0; i < relation[start].size(); i++) {
            int next = relation[start].get(i);

            if (!visited[next]) {
                dfs(next, end, depth + 1);
            }
        }
    }
}
```

## 결론

이 프로젝트는 깊이 우선 탐색(DFS)과 인접 리스트를 활용하여 두 노드 간의 촌수를 계산하는 문제를 해결합니다. 주어진 조건에 맞춰 정확하게 촌수를 계산하고, 없을 경우 -1을 출력하도록 구현되었습니다.