# 플로이드 와샬 알고리즘 (Floyd-Warshall Algorithm)

## 개요

플로이드 와샬 알고리즘은 모든 노드 쌍 간의 최단 경로를 찾기 위한 그래프 알고리즘입니다. 이 알고리즘은 가중치가 있는 방향성 또는 무방향성 그래프에 적용할 수 있으며, 음수 가중치도 허용하지만 음수 사이클이 있는 그래프에서는 사용할 수 없습니다.

## 알고리즘 설명

플로이드 와샬 알고리즘은 동적 프로그래밍을 사용하여 최단 경로를 찾습니다. 알고리즘은 주어진 그래프의 인접 행렬을 사용하여 모든 노드 쌍 사이의 최단 거리를 반복적으로 개선합니다.

## 동작 원리

1. **초기화**:
    - 그래프의 인접 행렬 `dist`를 초기화합니다. `dist[i][j]`는 노드 `i`에서 노드 `j`로 가는 경로의 가중치로 설정합니다. 직접 경로가 없으면 무한대로 설정합니다.
    - `dist[i][i]`는 0으로 설정합니다.

2. **반복 계산**:
    - 세 개의 중첩된 루프를 사용하여 모든 노드 쌍 `(i, j)`에 대해 중간 노드 `k`를 통해 경로를 개선할 수 있는지 확인합니다.
    - `dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])`로 업데이트합니다.

3. **결과**:
    - 모든 노드 쌍 `(i, j)`에 대해 최단 경로 `dist[i][j]`를 얻습니다.

## 시간 복잡도

플로이드 와샬 알고리즘의 시간 복잡도는 `O(V^3)`입니다. 여기서 `V`는 그래프의 노드 수입니다.

## 예제 코드

```java
import java.util.Arrays;

public class FloydWarshall {

    final static int INF = 99999; // 무한대 값을 설정합니다.

    public void floydWarshall(int graph[][], int V) {
        int dist[][] = new int[V][V];

        // 거리 배열을 초기화합니다.
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                dist[i][j] = graph[i][j];
            }
        }

        // 플로이드 와샬 알고리즘을 수행합니다.
        for (int k = 0; k < V; k++) {
            for (int i = 0; i < V; i++) {
                for (int j = 0; j < V; j++) {
                    if (dist[i][k] + dist[k][j] < dist[i][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }
            }
        }

        // 결과를 출력합니다.
        printSolution(dist, V);
    }

    void printSolution(int dist[][], int V) {
        System.out.println("각 노드 쌍 간의 최단 거리 행렬:");
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                if (dist[i][j] == INF) {
                    System.out.print("INF ");
                } else {
                    System.out.print(dist[i][j] + " ");
                }
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        FloydWarshall fw = new FloydWarshall();
        int graph[][] = {
            {0, 5, INF, 10},
            {INF, 0, 3, INF},
            {INF, INF, 0, 1},
            {INF, INF, INF, 0}
        };
        int V = 4;
        fw.floydWarshall(graph, V);
    }
}
```

## 사용법

1. `INF` 값은 그래프에서 직접 연결되지 않은 노드 쌍을 나타냅니다.
2. `graph` 배열은 주어진 그래프의 인접 행렬을 나타냅니다.
3. `floydWarshall` 메서드를 호출하여 그래프의 모든 노드 쌍 간의 최단 거리를 계산합니다.
4. `printSolution` 메서드를 통해 결과를 출력합니다.

## 참고

- 플로이드 와샬 알고리즘은 음수 가중치도 처리할 수 있지만, 음수 사이클이 있는 그래프에서는 사용할 수 없습니다.
- 알고리즘의 시간 복잡도는 `O(V^3)`이므로, 노드 수가 많은 그래프(100까지 추천)에서는 성능이 저하될 수 있습니다.